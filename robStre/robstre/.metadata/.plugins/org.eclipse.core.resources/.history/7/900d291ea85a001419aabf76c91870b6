package bolts;

import main.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import backtype.storm.task.TopologyContext;
import backtype.storm.topology.BasicOutputCollector;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseBasicBolt;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Tuple;
import backtype.storm.tuple.Values;

public class dftCalBolt extends BaseBasicBolt {

	// ............input time order..............//

	double curtstamp = TopologyMain.winSize - 1;
	String streType = new String();
	double ts = 0.0;

	String commandStr = new String();
	long preTaskId = 0;

	// .........memory management for sliding windows.................//

	Double[][] streamVec = new Double[TopologyMain.nstreBolt + 10][TopologyMain.winSize + 10];
	Double[][] dftVec = new Double[TopologyMain.nstreBolt + 10][TopologyMain.winSize + 10];
	int[][] cellVec = new int[TopologyMain.gridIdxN + 5][TopologyMain.winSize + 5];

	
	HashMap<Integer, Integer> streIdx = new HashMap<Integer, Integer>();
	HashMap<String, Integer> cellIdx = new HashMap<String, Integer>();
	
	List<List<Integer>> cellStre = new ArrayList<List<Integer>>(
			TopologyMain.gridIdxN + 5);
	
	ArrayList<String> resPair = new ArrayList<String>();

	// ...........computation parameter....................//
	int locTaskId;
	double disThre = 2 - 2 * TopologyMain.thre;
	double cellEps = Math.sqrt(disThre);
	HashSet<Long> preTaskIdx = new HashSet<Long>();

	public void updateStreVec(int memidx, String vecdata) {

		int len = vecdata.length(), pre = 0;
		vecst[memidx] = 0;
		veced[memidx] = 0;

		double exp = 0.0, sqrexp = 0.0, tmpval = 0.0;

		for (int i = 0; i < len; ++i) {
			if (vecdata.charAt(i) == ',') {

				tmpval = Double.valueOf(vecdata.substring(pre, i));

				vecData[memidx][veced[memidx]] = tmpval;
				veced[memidx] = (veced[memidx] + 1) % queueLen;

				exp = tmpval + exp;
				sqrexp = tmpval * tmpval + sqrexp;

				pre = i + 1;
			}
		}

		cursqrexp[memidx] = sqrexp / TopologyMain.winSize;
		curexp[memidx] = exp / TopologyMain.winSize;

		return;
	}

	public void updateStreData(int memidx, String vecdata) {

		double newval = Double.valueOf(vecdata), oldval = vecData[memidx][vecst[memidx]];

		vecData[memidx][veced[memidx]] = newval;

		cursqrexp[memidx] = cursqrexp[memidx] - oldval * oldval
				/ TopologyMain.winSize + newval * newval / TopologyMain.winSize;

		curexp[memidx] = curexp[memidx] - oldval / TopologyMain.winSize
				+ newval / TopologyMain.winSize;

		veced[memidx] = (veced[memidx] + 1) % queueLen;
		vecst[memidx] = (vecst[memidx] + 1) % queueLen;

		return;
	}

	public void vecAna(double mem[][],int idx, String vecstr )
	{
		int len=vecstr.length(),pre=0,cnt=0;
		double tmpval=0.0;
		
		for (int i = 0; i < len; ++i) {
			if (vecstr.charAt(i) == ',') {

				tmpval = Double.valueOf(vecstr.substring(pre, i));
				mem[idx][cnt++] = tmpval;
				
			}
		}
		
		return;
	}
	public void vecAnaInt(int mem[][],int idx, String vecstr )
	{
		int len=vecstr.length(),pre=0,cnt=0,tmpval=0;
		
		for (int i = 0; i < len; ++i) {
			if (vecstr.charAt(i) == ',') {

				tmpval = Integer.valueOf(vecstr.substring(pre, i));
				mem[idx][cnt++] = tmpval;
				
			}
		}
		
		return;
	}
	
	
	
	
	
	
	public void IndexingStre(int streid, String streamStr, String dftStr,String cell, int flag) {

		if (streIdx.containsKey(streid) == true) {
			return;
		}
		
		int streNo=streIdx.size();
		streIdx.put(streid, streNo);
		
		if (cellIdx.containsKey(cell) == true) {
			 
			cellStre.get( cellIdx.get(cell) ).add(streNo);
		}
		else
		{
			int cellNo=cellIdx.size();
			cellIdx.put(cell, cellNo);			
			 
			cellStre.add(new ArrayList<Integer>());
			 
			cellStre.get( cellIdx.get(cell) ).add(streNo);
		}
		
		
//		streamVec = new Double[TopologyMain.nstreBolt + 10][TopologyMain.winSize + 10];
//		Double[][] dftVec = new Double[TopologyMain.nstreBolt + 10][TopologyMain.winSize + 10];
//		int[][] cellVec
		
		
		vecAna(streamVec,streNo, streamVec );
		vecAna(dftVec,streNo, dftVec );
		vecAna(dftVec,streNo, dftVec );
		
//		vecAna(double mem[][],int idx, String vecstr )
		
		
		
		
//		if (streSet..contains(streid) == false) {
//			memidx = avaiMem.first();
//			avaiMem.remove(memidx);
//			streMem.put(streid, memidx);
//			updateStreVec(memidx, vecdata);
//		} else {
//			memidx = streMem.get(streid);
//			updateStreData(memidx, vecdata);
////			streSet.get(preset).remove(streid);
////		}
//
//		streTaskCoor[memidx] = taskcoor;
//		streSet.get(curSet).add(streid);
//
//		for (int iter : streSet.get(preset)) {
//			avaiMem.add(streMem.get(iter));
//			streMem.remove(iter);
//		}

		return;
	}

	int cellMemAlloc(String cellstr, int cellvec[]) {
		if (cellIdx.containsKey(cellstr) == true) {

			return cellIdx.get(cellstr);

		} else {

			cellIdx.put(cellstr, cellIdxcnt);

			for (int i = 0; i < TopologyMain.winSize; ++i) {
				cellVecs[cellIdxcnt][i] = cellvec[i];
			}

			cellIdxcnt++;

			cellHostStre.add(new ArrayList<Integer>());
			cellNbStre.add(new ArrayList<Integer>());

			return cellIdxcnt - 1;
		}
	}

	void cellStreamMapping() {

		int  memidx = 0, k = 0, cellmemidx = 0, cellcoor = 0, veccnt = 0;
		double denomi = 0.0, mean = 0.0, normcoor = 0.0;
		String cellstr = new String();

		int[] tmpvec = new int[TopologyMain.winSize + 5];
		
		for (Integer stre : streSet.get(curSet)) {
			
			memidx = streMem.get(stre);

			k = vecst[memidx];
			denomi = (cursqrexp[memidx] - curexp[memidx]) * TopologyMain.winSize;
			mean = curexp[memidx];
			veccnt = 0;

			if (Math.abs(denomi - 0.0) < 1e-6) {
				continue;
			}

			while (k != veced[memidx]) {

				normcoor =  ((vecData[memidx][k] - mean) / Math.sqrt(denomi));

				if (normcoor >= 0) {
					cellcoor = (int) Math.floor(normcoor / cellEps);
				} else {
					cellcoor = -1 * (int) Math.ceil(-1 * normcoor / cellEps);
				}

				cellstr = Integer.toString(cellcoor) + ",";
				tmpvec[veccnt++] = cellcoor;

				k = (k + 1) % queueLen;
			}

			cellmemidx = cellMemAlloc(cellstr, tmpvec);

			if (streTaskCoor[memidx] == locTaskId) {
				cellHostStre.get(cellmemidx).add(stre);
			} else {
				cellNbStre.get(cellmemidx).add(stre);
			}

		}

		return;
	}

	int cellVecCheck(int idx1, int idx2) {
		for (int j = 0; j < TopologyMain.winSize; ++j) {
			if (Math.abs(cellVecs[idx1][j] - cellVecs[idx2][j]) > 1) {
				return 0;
			}
		}
		return 1;
	}

	int correCalDis(double thre, int streid1, int streid2) {

		int memidx1 = streMem.get(streid1), memidx2 = streMem.get(streid2), k = vecst[memidx1];
		double deno1 = Math.sqrt((cursqrexp[memidx1] - curexp[memidx1])
				* TopologyMain.winSize), mean1 = curexp[memidx1];
		double deno2 = Math.sqrt((cursqrexp[memidx2] - curexp[memidx2])
				* TopologyMain.winSize), mean2 = curexp[memidx2];

		double tmpres = 0.0;

		while (k != veced[memidx1]) {

			tmpres = tmpres + (vecData[memidx1][k] - mean1)
					* (vecData[memidx2][k] - mean2);

			k = (k + 1) % queueLen;
		}
		tmpres = tmpres / (deno1 * deno2);

		return tmpres >= thre ? 1 : 0;

	}

	void cellWithinCal(int cellidx, ArrayList<String> res) {

		int stre1 = 0, stre2 = 0;
		for (int i = 0; i < cellHostStre.get(cellidx).size(); i++) {
			for (int j = i + 1; j < cellHostStre.get(cellidx).size(); j++) {

				stre1 = cellHostStre.get(cellidx).get(i);
				stre2 = cellHostStre.get(cellidx).get(j);

				if (correCalDis(TopologyMain.thre, stre1, stre2) == 1) {

//					if (stre1 > stre2)
//						res.add(Integer.toString(stre2) + ","
//								+ Integer.toString(stre1));
//					else
						res.add(Integer.toString(stre1) + ","
								+ Integer.toString(stre2));
				}

			}
		}

		for (int i = 0; i < cellHostStre.get(cellidx).size(); i++) {
			for (int j = 0; j < cellNbStre.get(cellidx).size(); j++) {

				stre1 = cellHostStre.get(cellidx).get(i);
				stre2 = cellNbStre.get(cellidx).get(j);

				if (correCalDis(TopologyMain.thre, stre1, stre2) == 1) {

//					if (stre1 > stre2)
//						res.add(Integer.toString(stre2) + ","
//								+ Integer.toString(stre1));
//					else
						res.add(Integer.toString(stre1) + ","
								+ Integer.toString(stre2));
				}

			}
		}

		return;
	}

	void cellInterCal(int cellidx1, int cellidx2, ArrayList<String> res) {

		int stre1 = 0, stre2 = 0, stre3 = 0, ini = 1;

		for (int i = 0; i < cellHostStre.get(cellidx1).size(); i++) {

			stre1 = cellHostStre.get(cellidx1).get(i);
			
			for (int j = 0; j < cellHostStre.get(cellidx2).size(); j++) {

				stre2 = cellHostStre.get(cellidx2).get(j);
				if (correCalDis(TopologyMain.thre, stre1, stre2) == 1) {

//					if (stre1 > stre2)
//						res.add(Integer.toString(stre2) + ","
//								+ Integer.toString(stre1));
//					else
						res.add(Integer.toString(stre1) + ","
								+ Integer.toString(stre2));
				}

				if (ini == 1) {

					for (int k = 0; k < cellNbStre.get(cellidx1).size(); k++) {
						stre3 = cellHostStre.get(cellidx1).get(k);

						if (correCalDis(TopologyMain.thre, stre2, stre3) == 1) {

//							if (stre3 > stre2)
//								res.add(Integer.toString(stre2) + ","
//										+ Integer.toString(stre3));
//							else
								res.add(Integer.toString(stre3) + ","
										+ Integer.toString(stre2));
						}
					}
					ini = 0;
				}
			}
		}

		for (int i = 0; i < cellHostStre.get(cellidx1).size(); i++) {
			for (int j = 0; j < cellNbStre.get(cellidx2).size(); j++) {

				stre1 = cellHostStre.get(cellidx1).get(i);
				stre2 = cellHostStre.get(cellidx2).get(j);

				
				if (correCalDis(TopologyMain.thre, stre1, stre2)==1)
				{
					res.add(Integer.toString(stre1) + ","
							+ Integer.toString(stre2));
				}
			}
		}

		return;
	}

	void cellCorrCal() {

		resPair.clear();

		for (int i = 0; i < cellIdxcnt; ++i) {

			cellWithinCal(i, resPair);
			for (int j = i + 1; j < cellIdxcnt; ++j) {
				if (cellVecCheck(i, j) == 1) {
					cellInterCal(i, j, resPair);
				}
			}
		}
		return;
	}

	public void localIdxRenew() {

		cellIdx.clear();
		cellIdxcnt = 0;

		cellHostStre.clear();
		cellNbStre.clear();
		resPair.clear();

		return;
	}

	@Override
	public void cleanup() {

	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer declarer) {
		// TODO Auto-generated method stub

		declarer.declare(new Fields("ts", "pair"));
	}

	@Override
	public void prepare(Map stormConf, TopologyContext context) {

		streSet.add(set1);
		streSet.add(set2);

		locTaskId = context.getThisTaskIndex();
		
		for(int i=0;i<TopologyMain.nstreBolt + 10;++i)
		{
			avaiMem.add(i);
		}

		return;
	}

	@Override
	public void execute(Tuple input, BasicOutputCollector collector) {
		// TODO Auto-generated method stub

//		declarer.declareStream("streamData", new Fields("ts", "streId",
//		"cellCoor", "strevec","dftvec", "hostFlag"));
//
//		declarer.declareStream("calCommand", new Fields("command", "taskid"));

		
	
		streType = input.getSourceStreamId();

		if (streType.compareTo("streamData") == 0) {

			ts = input.getDoubleByField("ts");
			String vecstr = input.getStringByField("strevec");
			String dftstr = input.getStringByField("dftvec");
			String cellstr = input.getStringByField("cellCoor");
			int streid = input.getIntegerByField("streId");
			int hostflag=input.getIntegerByField("hostFlag");

			if (Math.abs(curtstamp - ts) <= 1e-3) {
				IndexingStre(streid, vecstr, taskid);
			}

		} else if (streType.compareTo("calCommand") == 0) {

			commandStr = input.getStringByField("command");
			preTaskId = input.getLongByField("taskid");

			preTaskIdx.add(preTaskId);
			if (preTaskIdx.size() < TopologyMain.preBoltNum) {
				return;
			}

			cellStreamMapping();
			cellCorrCal();
			
			for(String pair:resPair)
			{
				collector.emit(new Values(curtstamp, pair)); 
			}
			localIdxRenew();

			curSet = 1 - curSet;
			streSet.get(curSet).clear();
			
			curtstamp = ts + 1;
			preTaskIdx.clear();
		}

		return;
	}
}

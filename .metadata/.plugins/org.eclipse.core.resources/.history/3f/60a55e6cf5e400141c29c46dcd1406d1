package bolts;

import java.util.HashSet;
import java.util.Map;

import main.TopologyMain;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.BasicOutputCollector;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseBasicBolt;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Tuple;
import backtype.storm.tuple.Values;

public class llcorrePre extends BaseBasicBolt {

	public int taskId = 0;

	// .........time order....................//

	double curtstamp = TopologyMain.winSize - 1;
	// public double ststamp = -TopologyMain.winSize+1;
	double ststamp = 0.0;
	String streType = new String();
	String commandStr = new String(), preCommandStr = new String();
	double ts = 0.0, retriTs = 0.0;
	// .........memory......................//

	int declrNum = (int) (TopologyMain.nstream / TopologyMain.preBoltNum + 1);
	double[][] strevec = new double[declrNum][TopologyMain.winSize + 2];
	double[][] normvec = new double[declrNum][TopologyMain.winSize + 2];

	int[] streid = new int[declrNum + 1];
	int streidCnt = 0;

	int[] vecst = new int[declrNum + 1];
	int[] veced = new int[declrNum + 1];
	int queueLen = TopologyMain.winSize + 1;

	int[] vecflag = new int[declrNum + 1];

	int iniFlag = 1;
	HashSet<Integer> oncePro = new HashSet<Integer>();

	// .........affine relation graph......................//

	// List<List<Integer>> graphmat = new ArrayList<List<Integer>>();
	//
	// List<List<Integer>> adjList = new ArrayList<List<Integer>>();
	// public int[] degree = new int[declrNum + 10];

	// ...........Computation parameter....................//

	final double disThre = 2 - 2 * TopologyMain.thre;
	final double epsilon = Math.sqrt(disThre);
	int localTaskIdx = 0;

	// ............custom metric............

	double emByte = 0.0, dirCnt = 0;

	// transient CountMetric _contData;

	void iniMetrics(TopologyContext context) {
		// _contData= new CountMetric();
		// context.registerMetric("emByte_count", _contData, 5);
	}

	void updateMetrics(double val, boolean isWin) {
		// _contData.incrBy((long)val);

		return;
	}

	// .....................................

	public double[] curexp = new double[declrNum + 10],
			curdev = new double[declrNum + 10],
			cursqr = new double[declrNum + 10],
			cursum = new double[declrNum + 10];



	public String prepCellVec(int memidx) {

		int k = 0;
		String str = new String();
		k = veced[memidx];
		double tmpnorm = 0.0;
		while (k != veced[memidx]) {

			tmpnorm = (strevec[memidx][k] - curexp[memidx])
					/ Math.sqrt(curdev[memidx]);

			if (tmpnorm >= 0) {

				str = str + (int) Math.floor((double) tmpnorm / epsilon) + ","; // watch
																				// out
																				// for:
																				// it
																				// is
																				// floor
				// here.

			} else {
				str = str + (-1)
						* (int) Math.ceil((double) -1 * tmpnorm / epsilon)
						+ ",";
			}

			k = (k + 1) % queueLen;
		}
		return str;
	}
	public String prepStreVec(int memidx) {

		int k = 0;
		String str = new String();
		k = veced[memidx];
		while (k != veced[memidx]) {

			str=str+ Double.toString(strevec[memidx][k]) + ",";

			k = (k + 1) % queueLen;
		}
		return str;
	}

	public void idxNewTuple(int strid, double val, int flag) {
		int i = 0, tmpsn = 0;
		double oldval = 0.0, newval = 0.0;

		for (i = 0; i < streidCnt; ++i) {
			if (streid[i] == strid) {
				tmpsn = i;
				break;
			}
		}
		if (i == streidCnt) {
			streid[i] = strid;
			tmpsn = streidCnt;
			streidCnt++;

		}

		if (vecflag[tmpsn] == 0) {

			strevec[tmpsn][veced[tmpsn]] = val;
			veced[tmpsn] = (veced[tmpsn] + 1) % queueLen;

			oldval = strevec[tmpsn][vecst[tmpsn]];
			newval = val;

			vecst[tmpsn] = (vecst[tmpsn] + 1 * flag) % queueLen;

			curexp[tmpsn] = curexp[tmpsn] - oldval / TopologyMain.winSize
					* flag + newval / TopologyMain.winSize;
			cursqr[tmpsn] = cursqr[tmpsn] - oldval * oldval * flag + newval
					* newval;
			cursum[tmpsn] = cursum[tmpsn] - oldval * flag + newval;

			curdev[tmpsn] = cursqr[tmpsn] + TopologyMain.winSize
					* curexp[tmpsn] * curexp[tmpsn] - 2 * cursum[tmpsn]
					* curexp[tmpsn];

			vecflag[tmpsn] = 1;

		}

	}


	@Override
	public void cleanup() {


	}

	@Override
	public void prepare(Map stormConf, TopologyContext context) {
		// TODO Auto-generated method stub

		taskId = context.getThisTaskId();
		localTaskIdx = context.getThisTaskIndex();

		for (int j = 0; j < declrNum + 1; j++) {
			vecst[j] = 0;
			veced[j] = 0;

			if (TopologyMain.iniWindow == 0) {
				veced[j] = TopologyMain.winSize - 1;
			}

			vecflag[j] = 0;
			streid[j] = 0;

			curexp[j] = 0;
			curdev[j] = 0;
			cursqr[j] = 0;
			cursum[j] = 0;
		}

		iniMetrics(context);
	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer declarer) {

		declarer.declareStream("dataTup", new Fields("id", "strevec",
				"cellvec", "ts"));

		declarer.declareStream("calCommand", new Fields("command", "taskid"));

		return;
	}

	@Override
	public void execute(Tuple input, BasicOutputCollector collector) {
		// TODO Auto-generated method stub

		int i = 0, tmppivot = 0;
//		int[] pivotset = new int[TopologyMain.nstream + 5];
//		int pivotcnt = 0;
//		int streIdx = 0;
//
//		String coorStr = new String();
//		String[] streAffine = new String[4];

		streType = input.getSourceStreamId();

		if (streType.compareTo("dataStre") == 0) {

			ts = input.getDoubleByField("ts");
			double tmpval = input.getDoubleByField("value");
			int sn = input.getIntegerByField("sn");

			if (oncePro.contains(sn) == false) {

				idxNewTuple(sn, tmpval, 1 - iniFlag);
				oncePro.add(sn);
			}

		} else if (streType.compareTo("contrStre") == 0) {

			commandStr = input.getStringByField("command");

			if (commandStr.compareTo(preCommandStr) == 0) {
				return;
			}

			if (ts - ststamp >= TopologyMain.winSize - 1) {

				ststamp++;
				// emByte = 0.0; // for window metric
				dirCnt = 0.0;

				// .............test............

				// if (ts == 15)
				// {
				//
				// System.out.printf("?????????? Prebolt %d has streams: ",
				// taskId);
				// for (int k = 0; k < streidCnt; ++k) {
				//
				// System.out.printf("%d, ", streid[k]);
				// }
				// System.out.printf("\n");
				//
				//
				// }

				// ..................

				// graphCons(TopologyMain.thre, collector, curtstamp);
				// pivotcnt = affineSelec(pivotset);

				for (i = 0; i < streidCnt; ++i) {

					// tmppivot = pivotset[i];
					// componConsAffine(tmppivot, streAffine);
					// coorStr = componGridCoor(tmppivot);

					// declarer.declareStream("interStre", new Fields("id",
					// "strevec",
					// "cellvec", "ts"));
					

					collector.emit("interStre", new Values(streid[tmppivot],
							prepStreVec(i),prepCellVec(i),curtstamp)); // modification
					iniFlag = 0;

					// .......comm byte metric........
					// emByte += (adjList.get(i).size() * 3 + 2 *
					// TopologyMain.winSize);

					// ...............................

				}
				collector
						.emit("calCommand",
								new Values("done" + Double.toString(curtstamp),
										taskId));

				// .......... custom metrics........
				updateMetrics(emByte, true);

				// ..........test.............

				// System.out
				// .printf("At time %f, PreBolt %d sends direct qualified stream %f\n",
				// curtstamp, taskId, dirCnt);

				// ..............................

				// ..........test.............
				// System.out
				// .printf("At time %f, PreBolt %d sends stream with cost %f, compared to naive cost %f\n",
				// curtstamp, taskId, emByte,
				// (double) TopologyMain.nstream/ TopologyMain.preBoltNum *
				// TopologyMain.winSize * 19);

				// ..............................
			}

			// .....update for next tuple...............//
			oncePro.clear();

			preCommandStr = commandStr;
			curtstamp = ts + 1;

			// graphmat.clear();
			// adjList.clear();
			for (int j = 0; j < declrNum + 1; ++j) {
				// degree[j] = 0;
				vecflag[j] = 0;
			}
		}

		// else if (streType.compareTo("retriStre") == 0) {
		// // declarer.declareStream("retriStre", new Fields("ts", "streId",
		// // "targetTask"));
		//
		// // add one hashing mechanism
		//
		// retriTs = input.getDoubleByField("ts");
		// String ids = input.getStringByField("streams");
		// int task = input.getIntegerByField("targetTask");
		//
		// int len = ids.length(), pre = 0, tmp = 0, streamCnt = 0, j = 0;
		// int[] streams = new int[declrNum];
		// String outStr = new String(), outVectors = new String(), tmpStr = new
		// String();
		//
		// // // .........test..........
		// // System.out
		// //
		// .printf("  ????????????? at time %f Prebolt %d receive stream ids:%s \n",
		// // retriTs, taskId, ids);
		//
		// // // .......................
		//
		// for (i = 0; i < len; ++i) {
		// if (ids.charAt(i) == ',') {
		//
		// tmpStr = ids.substring(pre, i);
		//
		// tmp = Integer.parseInt(tmpStr);
		//
		// // .........test..........
		// // System.out.printf(
		// // " !!!!!!!  Prebolt %d parse id %d from %s  \n",
		// // taskId, tmp, tmpStr);
		//
		// // .......................
		//
		// pre = i + 1;
		//
		// // j = 0;
		// // for (j = 0; j < streamCnt; ++j) {
		// // if (streams[j] == tmp) {
		// // break;
		// // }
		// // }
		// //
		// // if (j == streamCnt) {
		// // streams[streamCnt++] = tmp;
		//
		// for (int k = 0; k < streidCnt; ++k) {
		//
		// if (streid[k] == tmp) {
		// streIdx = k;
		// break;
		// }
		// }
		//
		// // .........test..........
		// // System.out
		// //
		// .printf("  ????????????? at time %f Prebolt %d get id %d from %s\n",
		// // retriTs, taskId, tmp, tmpStr);
		//
		// // .......................
		//
		// outStr = outStr + tmpStr + ",";
		// outVectors = outVectors + prepStream2Str(retriTs, streIdx);
		// //
		// // }
		// }
		// }
		//
		// // .........test..........
		// // System.out
		// //
		// .printf("  ????????????? at time %f Prebolt %d output ids %s  and vectors %s\n",
		// // retriTs, taskId, outStr, outVectors);
		//
		// // .......................
		//
		// collector.emitDirect(task, "winStre", new Values(retriTs, outStr,
		// outVectors, taskId));
		//
		// }
	}
}

